import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { askPanelStream, fetchInitialKeys, fetchStorageInfo, generateTitle } from "./api";
import { Markdown } from "./components/Markdown";
import { PanelConfigurator } from "./components/PanelConfigurator";
import { DebateViewer } from "./components/DebateViewer";
import { RegenerateModal } from "./components/RegenerateModal";
import { ThemeToggle } from "./components/theme-toggle";
import { fetchModelsForProvider, PROVIDER_LABELS } from "./lib/modelProviders";
import { findBestModelMatch } from "./lib/modelMatcher";
import { generateUniquePanelistName, isAutoGeneratedName } from "./lib/panelistNaming";
const DEFAULT_THREAD_ID = "demo-thread";
const parseJSON = (value, fallback) => {
    try {
        return value ? JSON.parse(value) : fallback;
    }
    catch {
        return fallback;
    }
};
const MAX_PANELISTS = 6;
const DEFAULT_PANELISTS = [
    { id: "panelist-1", name: "ChatGPT", provider: "openai", model: "" },
    { id: "panelist-2", name: "ChatGPT 2", provider: "openai", model: "" },
];
const MODERATOR_PANELIST = {
    id: "moderator",
    name: "Moderator",
    provider: "openai",
    model: "gpt-4o-mini",
};
const DEFAULT_DEBATE_MODE = false;
const DEFAULT_MAX_DEBATE_ROUNDS = 3;
const DEFAULT_STEP_REVIEW = false;
const createPanelist = (existingPanelists) => ({
    id: `panelist-${Date.now()}-${Math.random().toString(16).slice(2, 7)}`,
    name: "ChatGPT", // Will be updated with unique suffix if needed
    provider: "openai",
    model: "",
});
const MessageBubble = memo(function MessageBubble({ entry, onToggle, isLatest = false, messageRef, loadingStatus = "Panel is thinking...", status, statusTrail, searchSources = [], onCopy, onDelete, onRegenerate, onContinueDebate, containerWidth, }) {
    const [viewMode, setViewMode] = React.useState("list");
    const [carouselIndex, setCarouselIndex] = React.useState(0);
    const displayStatus = status ?? loadingStatus;
    const statusTrailText = (() => {
        if (!statusTrail || statusTrail.length <= 1)
            return null;
        const trimmed = statusTrail.slice(-6);
        const withoutCurrent = trimmed[trimmed.length - 1] === displayStatus ? trimmed.slice(0, -1) : trimmed;
        if (withoutCurrent.length === 0)
            return null;
        return withoutCurrent.slice(-3).join(" Â· ");
    })();
    return (_jsxs(motion.article, { ref: messageRef, className: "flex flex-col gap-6 min-w-0 group/message", initial: { opacity: 0, y: 8 }, animate: { opacity: 1, y: 0 }, transition: { duration: 0.5, ease: [0.16, 1, 0.3, 1] }, children: [_jsxs("div", { className: "flex flex-col items-end self-end text-right gap-2 w-full max-w-[90%] sm:max-w-[85%] md:max-w-[80%]", children: [_jsxs("div", { className: "flex items-center gap-2 w-full justify-end", children: [_jsx("span", { className: "text-[11px] font-medium tracking-wider uppercase text-muted-foreground/70 px-1", children: "You" }), _jsx("div", { className: "flex gap-1 opacity-0 group-hover/message:opacity-100 transition-opacity", children: onCopy && (_jsx("button", { type: "button", onClick: () => onCopy(entry.question), className: "p-1 rounded hover:bg-muted/40 transition-colors", title: "Copy question", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }), _jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })] }) })) })] }), _jsx(motion.div, { className: "w-full bg-foreground text-background rounded-2xl px-4 py-3 shadow-sm break-words max-h-[400px] overflow-y-auto prose-sm", initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { duration: 0.4, delay: 0.1, ease: [0.16, 1, 0.3, 1] }, children: _jsxs("div", { className: "text-sm leading-relaxed", children: [_jsx(Markdown, { content: entry.question }), entry.attachments.length > 0 && (_jsx("div", { className: "mt-4 flex flex-wrap gap-2.5", children: entry.attachments.map((src, index) => (_jsx(motion.img, { src: src, alt: `attachment-${index + 1}`, className: "w-20 h-20 object-cover rounded-xl border-2 border-background/30 shadow-sm", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, transition: { duration: 0.3, delay: 0.2 + index * 0.05 } }, index))) }))] }) })] }), _jsxs("div", { className: "flex flex-col items-start self-start text-left gap-2 w-full", children: [_jsxs("div", { className: "flex items-center gap-2 w-full flex-wrap", children: [_jsx("span", { className: "text-[11px] font-medium tracking-wider uppercase text-muted-foreground/70 px-1", children: "Panel" }), entry.summary && (_jsxs(_Fragment, { children: [entry.stopped ? (_jsxs("div", { className: "flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted/30 border border-border/40", children: [_jsx("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("rect", { x: "6", y: "6", width: "12", height: "12", rx: "1" }) }), _jsx("span", { className: "text-[10px] font-semibold text-muted-foreground uppercase tracking-wide", children: "Stopped" })] })) : entry.debate_mode && entry.debate_history && entry.debate_history.length > 0 ? (_jsxs("div", { className: "flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-accent/10 border border-accent/30", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-accent", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }), _jsx("path", { d: "M8 10h.01M12 10h.01M16 10h.01" })] }), _jsx("span", { className: "text-[10px] font-semibold text-accent uppercase tracking-wide", children: "Debate Mode" }), _jsxs("span", { className: "text-[10px] text-accent/70", children: [entry.debate_history.length, " round", entry.debate_history.length !== 1 ? 's' : '', entry.debate_history[entry.debate_history.length - 1]?.consensus_reached &&
                                                        _jsx("span", { className: "ml-1", children: "\u2022 Consensus \u2713" })] })] })) : (_jsxs("div", { className: "flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted/30 border border-border/40", children: [_jsx("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("path", { d: "M13 2L3 14h9l-1 8 10-12h-9l1-8z" }) }), _jsx("span", { className: "text-[10px] font-semibold text-muted-foreground uppercase tracking-wide", children: "Quick Response" })] })), entry.usage && entry.usage.total_tokens > 0 && (_jsxs("div", { className: "flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted/30 border border-border/40", title: `${entry.usage.total_input_tokens.toLocaleString()} input + ${entry.usage.total_output_tokens.toLocaleString()} output tokens`, children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("circle", { cx: "12", cy: "12", r: "10" }), _jsx("polyline", { points: "12 6 12 12 16 14" })] }), _jsxs("span", { className: "text-[10px] font-medium text-muted-foreground", children: [entry.usage.total_tokens >= 1000
                                                        ? `${(entry.usage.total_tokens / 1000).toFixed(1)}K`
                                                        : entry.usage.total_tokens, " tokens"] })] }))] })), _jsxs("div", { className: "flex gap-1 opacity-0 group-hover/message:opacity-100 transition-opacity ml-auto", children: [onCopy && entry.summary && (_jsx("button", { type: "button", onClick: () => onCopy(entry.summary), className: "p-1 rounded hover:bg-muted/40 transition-colors", title: "Copy response", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }), _jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })] }) })), onRegenerate && (_jsx("button", { type: "button", onClick: onRegenerate, className: "p-1 rounded hover:bg-muted/40 transition-colors", title: "Regenerate response", children: _jsx("svg", { viewBox: "0 0 24 24", className: "w-4 h-4 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: _jsx("path", { d: "M4 12a8 8 0 0 1 8-8 8 8 0 0 1 6.18 2.82l2.82-2.82M20 4v6h-6M20 12a8 8 0 0 1-8 8 8 8 0 0 1-6.18-2.82l-2.82 2.82M4 20v-6h6" }) }) })), onDelete && (_jsx("button", { type: "button", onClick: onDelete, className: "p-1 rounded hover:bg-destructive/20 transition-colors", title: "Delete message", children: _jsx("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-muted-foreground hover:text-destructive", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("path", { d: "M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }) }) }))] })] }), _jsx(motion.div, { className: "w-full break-words", initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: 0.4, delay: 0.2, ease: [0.16, 1, 0.3, 1] }, children: entry.summary || entry.debate_paused ? (_jsxs(_Fragment, { children: [entry.stopped ? (_jsxs("div", { className: "flex items-center gap-2 text-muted-foreground py-2", children: [_jsx("svg", { viewBox: "0 0 24 24", className: "w-4 h-4 flex-shrink-0", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("rect", { x: "6", y: "6", width: "12", height: "12", rx: "1" }) }), _jsx("span", { className: "text-sm italic", children: entry.summary })] })) : entry.summary ? (_jsx("div", { className: "prose prose-sm dark:prose-invert max-w-none", children: _jsx(Markdown, { content: entry.summary }) })) : (_jsxs("div", { className: "flex items-center gap-2 text-muted-foreground py-2", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4 flex-shrink-0", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M12 8v4l3 3" }), _jsx("circle", { cx: "12", cy: "12", r: "9" })] }), _jsx("span", { className: "text-sm italic", children: "Debate paused for review." })] })), !entry.stopped && entry.debate_mode && entry.debate_history && entry.debate_history.length > 0 ? (_jsx(DebateViewer, { debateHistory: entry.debate_history, panelists: entry.panelists, onCopy: onCopy, stepReview: entry.step_review, debatePaused: entry.debate_paused, onContinue: onContinueDebate, tagged_panelists: entry.tagged_panelists, user_as_participant: entry.user_as_participant })) : !entry.stopped ? (_jsxs(_Fragment, { children: [_jsxs("div", { className: "mt-5 flex items-center gap-3", children: [_jsxs("button", { type: "button", className: "inline-flex items-center gap-2 text-[13px] font-medium bg-transparent text-accent/90 border-none p-0 cursor-pointer hover:text-accent transition-colors", onClick: onToggle, children: [entry.expanded ? "Hide individual responses" : "Show individual responses", _jsx("svg", { viewBox: "0 0 24 24", "aria-hidden": "true", className: `w-3.5 h-3.5 transition-transform duration-200 ${entry.expanded ? "rotate-180" : ""}`, children: _jsx("path", { fill: "currentColor", d: "M7 10l5 5 5-5z" }) })] }), entry.expanded && Object.keys(entry.panel_responses).length > 1 && (_jsxs("div", { className: "flex gap-1 border border-border/50 rounded-md p-0.5", children: [_jsx("button", { type: "button", onClick: () => setViewMode("list"), className: `px-2 py-1 text-[11px] rounded transition-colors ${viewMode === "list"
                                                                ? "bg-foreground/10 text-foreground"
                                                                : "text-muted-foreground hover:text-foreground"}`, title: "List view", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("line", { x1: "8", y1: "6", x2: "21", y2: "6" }), _jsx("line", { x1: "8", y1: "12", x2: "21", y2: "12" }), _jsx("line", { x1: "8", y1: "18", x2: "21", y2: "18" }), _jsx("line", { x1: "3", y1: "6", x2: "3.01", y2: "6" }), _jsx("line", { x1: "3", y1: "12", x2: "3.01", y2: "12" }), _jsx("line", { x1: "3", y1: "18", x2: "3.01", y2: "18" })] }) }), _jsx("button", { type: "button", onClick: () => setViewMode("grid"), className: `px-2 py-1 text-[11px] rounded transition-colors ${viewMode === "grid"
                                                                ? "bg-foreground/10 text-foreground"
                                                                : "text-muted-foreground hover:text-foreground"}`, title: "Grid view", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "3", y: "3", width: "7", height: "7" }), _jsx("rect", { x: "14", y: "3", width: "7", height: "7" }), _jsx("rect", { x: "14", y: "14", width: "7", height: "7" }), _jsx("rect", { x: "3", y: "14", width: "7", height: "7" })] }) })] }))] }), _jsx(AnimatePresence, { children: entry.expanded && (_jsx(motion.div, { className: viewMode === "grid" ? "mt-6 border-t border-border/50 pt-6" : "mt-6 border-t border-border/50 pt-6", initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, transition: { duration: 0.3, ease: [0.16, 1, 0.3, 1] }, children: viewMode === "grid" ? (
                                                // Carousel view - break out of max-w-3xl constraint to fill scroll container
                                                _jsx("div", { className: "relative", style: containerWidth ? {
                                                        width: `${containerWidth}px`,
                                                        left: '50%',
                                                        transform: 'translateX(-50%)',
                                                        paddingLeft: '3rem',
                                                        paddingRight: '3rem',
                                                    } : undefined, children: (() => {
                                                        const responses = Object.entries(entry.panel_responses);
                                                        const itemsPerPage = 3;
                                                        const totalPages = Math.ceil(responses.length / itemsPerPage);
                                                        const startIdx = carouselIndex * itemsPerPage;
                                                        const visibleResponses = responses.slice(startIdx, startIdx + itemsPerPage);
                                                        const showPrevButton = carouselIndex > 0;
                                                        const showNextButton = carouselIndex < totalPages - 1;
                                                        return (_jsxs(_Fragment, { children: [showPrevButton && (_jsx("button", { onClick: () => setCarouselIndex(carouselIndex - 1), className: "absolute left-0 top-1/2 -translate-y-1/2 -translate-x-4 z-10 w-10 h-10 rounded-full bg-background border border-border shadow-lg flex items-center justify-center hover:bg-muted transition-colors", "aria-label": "Previous", children: _jsx("svg", { viewBox: "0 0 24 24", className: "w-5 h-5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("polyline", { points: "15 18 9 12 15 6" }) }) })), _jsx("div", { className: "flex gap-4 justify-center", children: visibleResponses.map(([name, text], idx) => {
                                                                        // Find the panelist config to show model info
                                                                        const panelist = entry.panelists.find((p) => p.name === name);
                                                                        return (_jsxs(motion.article, { className: "border border-border/40 rounded-2xl p-5 bg-muted/20 hover:bg-muted/30 transition-colors group/response flex-1 min-w-0 max-w-[calc(33.333%-0.67rem)]", initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, transition: { duration: 0.3, delay: idx * 0.05 }, children: [_jsxs("div", { className: "flex items-center justify-between gap-3 mb-3", children: [_jsxs("div", { className: "flex items-center gap-2", children: [_jsx("div", { className: "w-8 h-8 rounded-full bg-accent/10 flex items-center justify-center text-accent font-semibold text-xs", children: name.charAt(0).toUpperCase() }), _jsxs("div", { className: "flex flex-col", children: [_jsx("h4", { className: "m-0 text-foreground text-[13px] font-semibold tracking-wide", children: name }), panelist && (_jsxs("span", { className: "text-[10px] text-muted-foreground mt-0.5", children: [PROVIDER_LABELS[panelist.provider], " \u00B7 ", panelist.model] }))] })] }), onCopy && (_jsx("button", { type: "button", onClick: () => onCopy(text), className: "opacity-0 group-hover/response:opacity-100 p-1.5 rounded hover:bg-muted/40 transition-all", title: "Copy response", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }), _jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })] }) }))] }), _jsx("div", { className: "text-[13px] leading-relaxed text-muted-foreground prose prose-sm dark:prose-invert max-w-none", children: _jsx(Markdown, { content: text }) })] }, name));
                                                                    }) }), showNextButton && (_jsx("button", { onClick: () => setCarouselIndex(carouselIndex + 1), className: "absolute right-0 top-1/2 -translate-y-1/2 translate-x-4 z-10 w-10 h-10 rounded-full bg-background border border-border shadow-lg flex items-center justify-center hover:bg-muted transition-colors", "aria-label": "Next", children: _jsx("svg", { viewBox: "0 0 24 24", className: "w-5 h-5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("polyline", { points: "9 18 15 12 9 6" }) }) })), totalPages > 1 && (_jsx("div", { className: "flex justify-center gap-2 mt-4", children: Array.from({ length: totalPages }).map((_, i) => (_jsx("button", { onClick: () => setCarouselIndex(i), className: `w-2 h-2 rounded-full transition-colors ${i === carouselIndex ? "bg-accent" : "bg-border hover:bg-muted-foreground"}`, "aria-label": `Go to page ${i + 1}` }, i))) }))] }));
                                                    })() })) : (
                                                // List view
                                                _jsx("div", { className: "flex flex-col gap-4", children: Object.entries(entry.panel_responses).map(([name, text], idx) => {
                                                        const panelist = entry.panelists.find((p) => p.name === name);
                                                        return (_jsxs(motion.article, { className: "border border-border/40 rounded-2xl p-5 bg-muted/20 hover:bg-muted/30 transition-colors group/response", initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, transition: { duration: 0.3, delay: idx * 0.05 }, children: [_jsxs("div", { className: "flex items-center justify-between gap-3 mb-3", children: [_jsxs("div", { className: "flex items-center gap-2", children: [_jsx("div", { className: "w-8 h-8 rounded-full bg-accent/10 flex items-center justify-center text-accent font-semibold text-xs", children: name.charAt(0).toUpperCase() }), _jsxs("div", { className: "flex flex-col", children: [_jsx("h4", { className: "m-0 text-foreground text-[13px] font-semibold tracking-wide", children: name }), panelist && (_jsxs("span", { className: "text-[10px] text-muted-foreground mt-0.5", children: [PROVIDER_LABELS[panelist.provider], " \u00B7 ", panelist.model] }))] })] }), onCopy && (_jsx("button", { type: "button", onClick: () => onCopy(text), className: "opacity-0 group-hover/response:opacity-100 p-1.5 rounded hover:bg-muted/40 transition-all", title: "Copy response", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }), _jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })] }) }))] }), _jsx("div", { className: "text-[13px] leading-relaxed text-muted-foreground prose prose-sm dark:prose-invert max-w-none", children: _jsx(Markdown, { content: text }) })] }, name));
                                                    }) })) })) })] })) : null] })) : (_jsxs("div", { className: "flex flex-col gap-2", children: [entry.debate_mode && (_jsxs("div", { className: "flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-accent/10 border border-accent/30 w-fit", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-accent", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }), _jsx("path", { d: "M8 10h.01M12 10h.01M16 10h.01" })] }), _jsx("span", { className: "text-[10px] font-semibold text-accent uppercase tracking-wide", children: "Debate Mode" })] })), _jsxs("div", { className: "flex items-center gap-3", children: [_jsxs(motion.div, { className: `flex gap-1.5 ${entry.debate_mode ? 'text-accent' : ''}`, initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: 0.3 }, children: [_jsx(motion.div, { className: `w-2 h-2 rounded-full ${entry.debate_mode ? 'bg-accent/40' : 'bg-muted-foreground/40'}`, animate: { scale: [1, 1.2, 1], opacity: [0.4, 0.8, 0.4] }, transition: { duration: 1.2, repeat: Infinity, delay: 0 } }), _jsx(motion.div, { className: `w-2 h-2 rounded-full ${entry.debate_mode ? 'bg-accent/40' : 'bg-muted-foreground/40'}`, animate: { scale: [1, 1.2, 1], opacity: [0.4, 0.8, 0.4] }, transition: { duration: 1.2, repeat: Infinity, delay: 0.2 } }), _jsx(motion.div, { className: `w-2 h-2 rounded-full ${entry.debate_mode ? 'bg-accent/40' : 'bg-muted-foreground/40'}`, animate: { scale: [1, 1.2, 1], opacity: [0.4, 0.8, 0.4] }, transition: { duration: 1.2, repeat: Infinity, delay: 0.4 } })] }), _jsx("span", { className: `text-[13px] ${entry.debate_mode ? 'text-accent/70' : 'text-muted-foreground/60'}`, children: displayStatus })] }), statusTrailText && (_jsx("div", { className: "text-[11px] text-muted-foreground/50 pl-7", children: statusTrailText })), searchSources.length > 0 && (_jsx(motion.div, { className: "flex flex-wrap gap-2 ml-7", initial: { opacity: 0, y: -5 }, animate: { opacity: 1, y: 0 }, transition: { duration: 0.3 }, children: searchSources.map((source, index) => {
                                        const domain = new URL(source.url).hostname;
                                        const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;
                                        return (_jsxs(motion.a, { href: source.url, target: "_blank", rel: "noopener noreferrer", className: "flex items-center gap-2 px-2 py-1.5 rounded-lg bg-muted/50 hover:bg-muted/80 transition-colors text-xs text-muted-foreground max-w-[200px]", initial: { opacity: 0, scale: 0.9 }, animate: { opacity: 1, scale: 1 }, transition: { duration: 0.2, delay: index * 0.05 }, title: source.title, children: [_jsx("img", { src: faviconUrl, alt: "", className: "w-4 h-4 flex-shrink-0", onError: (e) => {
                                                        // Fallback to a generic icon if favicon fails to load
                                                        e.currentTarget.style.display = 'none';
                                                    } }), _jsx("span", { className: "truncate", children: source.title })] }, index));
                                    }) }))] })) })] })] }));
});
MessageBubble.displayName = "MessageBubble";
export default function App() {
    const [threadId, setThreadId] = useState(() => localStorage.getItem("threadId") ?? DEFAULT_THREAD_ID);
    const [threads, setThreads] = useState(() => {
        const stored = parseJSON(localStorage.getItem("threads"), []);
        if (!stored.includes(DEFAULT_THREAD_ID)) {
            stored.unshift(DEFAULT_THREAD_ID);
        }
        return Array.from(new Set(stored));
    });
    const [conversations, setConversations] = useState(() => {
        const raw = parseJSON(localStorage.getItem("conversations"), {});
        const normalized = {};
        Object.entries(raw).forEach(([id, entries]) => {
            normalized[id] = (entries ?? []).map((entry) => ({
                ...entry,
                attachments: entry.attachments ?? [],
                panel_responses: entry.panel_responses ?? {},
                panelists: entry.panelists ?? [], // Fallback for old messages without panelists
                expanded: Boolean(entry.expanded),
            }));
        });
        if (!normalized[DEFAULT_THREAD_ID]) {
            normalized[DEFAULT_THREAD_ID] = [];
        }
        return normalized;
    });
    const [editingThreadId, setEditingThreadId] = useState(null);
    const [editingThreadName, setEditingThreadName] = useState("");
    const [threadMenuOpen, setThreadMenuOpen] = useState(null);
    const [panelists, setPanelists] = useState(() => {
        const stored = parseJSON(localStorage.getItem("panelists"), DEFAULT_PANELISTS);
        return stored.length > 0 ? stored : DEFAULT_PANELISTS;
    });
    const [providerKeys, setProviderKeys] = useState(() => parseJSON(localStorage.getItem("providerKeys"), {}));
    const [providerModels, setProviderModels] = useState(() => parseJSON(localStorage.getItem("providerModels"), {}));
    const [modelStatus, setModelStatus] = useState({});
    const [configOpen, setConfigOpen] = useState(false);
    const [showKeyboardShortcuts, setShowKeyboardShortcuts] = useState(false);
    const [regenerateModalOpen, setRegenerateModalOpen] = useState(false);
    const [regenerateIndex, setRegenerateIndex] = useState(null);
    const [loading, setLoading] = useState(false);
    const [loadingStatus, setLoadingStatus] = useState("Panel is thinking...");
    const [activeEntryId, setActiveEntryId] = useState(null);
    const [statusByEntryId, setStatusByEntryId] = useState({});
    const [statusTrailByEntryId, setStatusTrailByEntryId] = useState({});
    const [searchSources, setSearchSources] = useState([]);
    const [error, setError] = useState(null);
    const [abortController, setAbortController] = useState(null);
    const [showScrollToBottom, setShowScrollToBottom] = useState(false);
    const [storageInfo, setStorageInfo] = useState(null);
    const [sidebarVisible, setSidebarVisible] = useState(() => {
        const stored = localStorage.getItem("sidebarVisible");
        return stored !== null ? stored === "true" : true; // Default to visible
    });
    const [enabledPanelists, setEnabledPanelists] = useState(() => {
        const stored = localStorage.getItem("enabledPanelists");
        if (stored) {
            try {
                const parsed = JSON.parse(stored);
                return new Set(Array.isArray(parsed) ? parsed : []);
            }
            catch {
                return new Set();
            }
        }
        // Default: all panelists enabled
        return new Set(panelists.map((p) => p.id));
    });
    const renameInputRef = useRef(null);
    const messageListRef = useRef(null);
    const latestMessageRef = useRef(null);
    const [scrollContainerWidth, setScrollContainerWidth] = useState(0);
    // Measure scroll container width for carousel full-width expansion
    useEffect(() => {
        const measureWidth = () => {
            if (messageListRef.current) {
                setScrollContainerWidth(messageListRef.current.clientWidth);
            }
        };
        measureWidth();
        window.addEventListener("resize", measureWidth);
        return () => window.removeEventListener("resize", measureWidth);
    }, []);
    const messages = conversations[threadId] ?? [];
    const setEntryStatus = useCallback((entryId, message) => {
        setStatusByEntryId((prev) => (prev[entryId] === message ? prev : { ...prev, [entryId]: message }));
        setStatusTrailByEntryId((prev) => {
            const existing = prev[entryId] ?? [];
            const next = existing[existing.length - 1] === message ? existing : [...existing, message];
            const trimmed = next.length > 6 ? next.slice(next.length - 6) : next;
            return { ...prev, [entryId]: trimmed };
        });
    }, []);
    const clearEntryStatus = useCallback((entryId) => {
        setStatusByEntryId((prev) => {
            if (!(entryId in prev))
                return prev;
            const { [entryId]: _removed, ...rest } = prev;
            return rest;
        });
        setStatusTrailByEntryId((prev) => {
            if (!(entryId in prev))
                return prev;
            const { [entryId]: _removed, ...rest } = prev;
            return rest;
        });
    }, []);
    const activeEntry = useMemo(() => {
        if (!activeEntryId)
            return null;
        return messages.find((entry) => entry.id === activeEntryId) ?? null;
    }, [activeEntryId, messages]);
    // Auto-scroll to latest message when messages change
    useEffect(() => {
        if (latestMessageRef.current && messages.length > 0) {
            // Small delay to allow DOM to update
            setTimeout(() => {
                latestMessageRef.current?.scrollIntoView({
                    behavior: "smooth",
                    block: "end"
                });
            }, 100);
        }
    }, [messages.length]);
    useEffect(() => {
        localStorage.setItem("threadId", threadId);
    }, [threadId]);
    useEffect(() => {
        localStorage.setItem("threads", JSON.stringify(threads));
    }, [threads]);
    useEffect(() => {
        localStorage.setItem("conversations", JSON.stringify(conversations));
    }, [conversations]);
    useEffect(() => {
        localStorage.setItem("panelists", JSON.stringify(panelists));
    }, [panelists]);
    useEffect(() => {
        localStorage.setItem("providerKeys", JSON.stringify(providerKeys));
    }, [providerKeys]);
    useEffect(() => {
        localStorage.setItem("providerModels", JSON.stringify(providerModels));
    }, [providerModels]);
    useEffect(() => {
        localStorage.setItem("sidebarVisible", String(sidebarVisible));
    }, [sidebarVisible]);
    useEffect(() => {
        localStorage.setItem("enabledPanelists", JSON.stringify(Array.from(enabledPanelists)));
    }, [enabledPanelists]);
    // Sync enabled panelists when panelists change (enable new ones by default)
    useEffect(() => {
        setEnabledPanelists((prev) => {
            const newEnabled = new Set(prev);
            panelists.forEach((p) => {
                if (!newEnabled.has(p.id)) {
                    newEnabled.add(p.id);
                }
            });
            // Remove IDs that no longer exist
            const currentIds = new Set(panelists.map((p) => p.id));
            Array.from(newEnabled).forEach((id) => {
                if (!currentIds.has(id)) {
                    newEnabled.delete(id);
                }
            });
            return newEnabled;
        });
    }, [panelists]);
    useEffect(() => {
        if (!threads.includes(threadId)) {
            setThreads((prev) => Array.from(new Set([...prev, threadId])));
        }
        if (!conversations[threadId]) {
            setConversations((prev) => ({ ...prev, [threadId]: [] }));
        }
    }, [threadId, threads, conversations]);
    // Auto-focus rename input when editing starts
    useEffect(() => {
        if (editingThreadId) {
            const frame = requestAnimationFrame(() => {
                renameInputRef.current?.focus();
                renameInputRef.current?.select();
            });
            return () => cancelAnimationFrame(frame);
        }
    }, [editingThreadId]);
    // Close thread menu when clicking outside
    useEffect(() => {
        if (!threadMenuOpen)
            return;
        function handleClickOutside(e) {
            const target = e.target;
            if (!target.closest('[data-thread-menu]')) {
                setThreadMenuOpen(null);
            }
        }
        document.addEventListener('click', handleClickOutside);
        return () => document.removeEventListener('click', handleClickOutside);
    }, [threadMenuOpen]);
    // Fetch initial API keys from environment variables on mount
    useEffect(() => {
        async function loadInitialKeys() {
            console.log('[API Keys] Fetching initial keys from backend...');
            const initialKeys = await fetchInitialKeys();
            console.log('[API Keys] Received from backend:', Object.keys(initialKeys).filter(k => initialKeys[k]).join(', ') || 'none');
            // Only populate keys that aren't already set in localStorage
            const storedKeys = parseJSON(localStorage.getItem("providerKeys"), {});
            console.log('[API Keys] Stored keys in localStorage:', Object.keys(storedKeys).filter(k => storedKeys[k]?.trim()).join(', ') || 'none');
            const mergedKeys = { ...storedKeys };
            let keysAdded = 0;
            for (const [provider, key] of Object.entries(initialKeys)) {
                // Only use environment key if no stored key exists
                if (key && !storedKeys[provider]?.trim()) {
                    mergedKeys[provider] = key;
                    keysAdded++;
                    console.log(`[API Keys] Added ${provider} key from backend`);
                }
            }
            // Update state if we have new keys
            if (JSON.stringify(mergedKeys) !== JSON.stringify(storedKeys)) {
                console.log(`[API Keys] Updating provider keys (${keysAdded} new keys)`);
                setProviderKeys(mergedKeys);
            }
            else {
                console.log('[API Keys] No new keys to add');
            }
        }
        loadInitialKeys();
    }, []); // Run only once on mount
    // Fetch storage mode information on mount
    useEffect(() => {
        async function loadStorageInfo() {
            const info = await fetchStorageInfo();
            setStorageInfo(info);
            console.log('[Storage] Mode:', info.mode, '- Persistent:', info.persistent);
        }
        loadStorageInfo();
    }, []); // Run only once on mount
    // Keyboard shortcuts
    useEffect(() => {
        function handleKeyboardShortcut(e) {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const modKey = isMac ? e.metaKey : e.ctrlKey;
            // Cmd/Ctrl + N: New thread
            if (modKey && e.key === 'n') {
                e.preventDefault();
                handleCreateThread();
            }
            // Cmd/Ctrl + /: Toggle settings
            if (modKey && e.key === '/') {
                e.preventDefault();
                setConfigOpen((prev) => !prev);
            }
            // Esc: Close modals
            if (e.key === 'Escape') {
                if (showKeyboardShortcuts) {
                    e.preventDefault();
                    setShowKeyboardShortcuts(false);
                }
                if (configOpen) {
                    e.preventDefault();
                    setConfigOpen(false);
                }
                if (editingThreadId) {
                    e.preventDefault();
                    cancelThreadRename();
                }
                if (threadMenuOpen) {
                    e.preventDefault();
                    setThreadMenuOpen(null);
                }
            }
        }
        window.addEventListener('keydown', handleKeyboardShortcut);
        return () => window.removeEventListener('keydown', handleKeyboardShortcut);
    }, [configOpen, showKeyboardShortcuts, editingThreadId, threadMenuOpen]);
    const togglePanelist = useCallback((id) => {
        setEnabledPanelists((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(id)) {
                // Don't allow disabling the last panelist
                if (newSet.size <= 1) {
                    return prev;
                }
                newSet.delete(id);
            }
            else {
                newSet.add(id);
            }
            return newSet;
        });
    }, []);
    // Parse @ mentions from user input to extract tagged panelist names
    const parseTaggedPanelists = useCallback((text) => {
        // Match @Name patterns (case-insensitive, fuzzy matching)
        const mentions = text.match(/@(\w+(?:\s+\w+)*)/g) || [];
        const tagged = [];
        for (const mention of mentions) {
            const searchTerm = mention.slice(1).toLowerCase(); // Remove @ and lowercase
            // Find matching panelist using fuzzy match
            const match = panelists.find(p => p.name.toLowerCase().includes(searchTerm) || searchTerm.includes(p.name.toLowerCase()));
            if (match) {
                tagged.push(match.name);
            }
        }
        // Deduplicate and return
        return [...new Set(tagged)];
    }, [panelists]);
    const preparedPanelists = useMemo(() => panelists
        .filter((panelist) => enabledPanelists.has(panelist.id))
        .map((panelist, index) => ({
        ...panelist,
        name: panelist.name.trim() || `Panelist ${index + 1}`,
    })), [panelists, enabledPanelists]);
    const panelistSummaries = useMemo(() => panelists.map((panelist, index) => ({
        id: panelist.id,
        name: panelist.name.trim() || `Panelist ${index + 1}`,
        provider: PROVIDER_LABELS[panelist.provider],
        model: panelist.model,
        enabled: enabledPanelists.has(panelist.id),
    })), [panelists, enabledPanelists]);
    const sanitizedProviderKeys = useMemo(() => {
        const entries = Object.entries(providerKeys).filter(([, value]) => Boolean(value?.trim()));
        return Object.fromEntries(entries.map(([key, value]) => [key, value.trim()]));
    }, [providerKeys]);
    const handleSend = useCallback(async ({ question, attachments, customDebateMode, customMaxRounds, customStepReview, }) => {
        const hasContent = Boolean(question.trim()) || attachments.length > 0;
        if (!hasContent || loading) {
            return;
        }
        setLoading(true);
        setError(null);
        setSearchSources([]); // Clear previous search sources
        // Create abort controller for this request
        const controller = new AbortController();
        setAbortController(controller);
        const sanitizedQuestion = question.trim() || "See attached images.";
        const entryId = `${threadId}-${Date.now()}`;
        setActiveEntryId(entryId);
        setEntryStatus(entryId, "Starting...");
        const useDebateMode = customDebateMode ?? DEFAULT_DEBATE_MODE;
        const useMaxRounds = customMaxRounds ?? DEFAULT_MAX_DEBATE_ROUNDS;
        const useStepReview = customStepReview ?? DEFAULT_STEP_REVIEW;
        // Parse @ mentions to detect user-debate mode
        const taggedPanelists = parseTaggedPanelists(sanitizedQuestion);
        const userAsParticipant = taggedPanelists.length > 0;
        // If user tags panelists, activate debate mode with step review
        const effectiveDebateMode = userAsParticipant ? true : useDebateMode;
        const effectiveStepReview = userAsParticipant ? true : useStepReview;
        // Immediately add user message with loading state for assistant response
        const optimisticEntry = {
            id: entryId,
            question: sanitizedQuestion,
            attachments,
            summary: "", // Will be filled when response arrives
            panel_responses: {},
            panelists: panelists, // Store panelist configs to show model info later
            expanded: false,
            debate_mode: useDebateMode,
            max_debate_rounds: useMaxRounds,
            step_review: useStepReview,
            debate_history: [],
            user_as_participant: userAsParticipant,
            tagged_panelists: taggedPanelists,
        };
        setConversations((prev) => ({
            ...prev,
            [threadId]: [...(prev[threadId] ?? []), optimisticEntry],
        }));
        try {
            await askPanelStream({
                thread_id: threadId.trim(),
                question: sanitizedQuestion,
                attachments,
                panelists: preparedPanelists,
                provider_keys: sanitizedProviderKeys,
                debate_mode: effectiveDebateMode,
                max_debate_rounds: useMaxRounds,
                step_review: effectiveStepReview,
                user_as_participant: userAsParticipant,
                tagged_panelists: taggedPanelists,
                user_message: userAsParticipant ? sanitizedQuestion : undefined,
            }, {
                onStatus: (message) => {
                    setLoadingStatus(message);
                    setEntryStatus(entryId, message);
                },
                onDebateRound: (round) => {
                    setEntryStatus(entryId, `Round ${round.round_number + 1} complete`);
                    // Update the entry with the new debate round in real-time
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((entry) => entry.id === entryId
                            ? {
                                ...entry,
                                debate_history: [...(entry.debate_history || []), round],
                            }
                            : entry) ?? [],
                    }));
                },
                onDebatePaused: (result) => {
                    setEntryStatus(entryId, "Paused for review");
                    // Debate paused for user review
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((entry) => entry.id === entryId
                            ? {
                                ...entry,
                                panel_responses: result.panel_responses || entry.panel_responses,
                                debate_history: entry.debate_history,
                                debate_paused: true,
                                usage: result.usage || entry.usage,
                            }
                            : entry) ?? [],
                    }));
                    // Clear loading state when debate pauses
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                },
                onSearchSource: (source) => {
                    setSearchSources((prev) => [...prev, source]);
                },
                onPanelistResponse: (panelist, response) => {
                    // Update the entry with the individual panelist response
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((entry) => entry.id === entryId
                            ? {
                                ...entry,
                                panel_responses: {
                                    ...entry.panel_responses,
                                    [panelist]: response,
                                },
                            }
                            : entry) ?? [],
                    }));
                },
                onResult: (result) => {
                    clearEntryStatus(entryId);
                    // Update the entry with the actual response
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((entry) => entry.id === entryId
                            ? {
                                ...entry,
                                summary: result.summary,
                                panel_responses: result.panel_responses,
                                // Keep accumulated debate history from streaming (onDebateRound)
                                debate_history: entry.debate_history,
                                debate_paused: false,
                                usage: result.usage,
                            }
                            : entry) ?? [],
                    }));
                    // Auto-generate title if this thread has a placeholder name
                    // (only the first message will trigger this since after first message,
                    // the title is updated to a real name, so placeholder check is sufficient)
                    const isPlaceholderTitle = threadId.startsWith("Chat ");
                    if (isPlaceholderTitle) {
                        // Generate title in background (don't await)
                        generateTitle(sanitizedQuestion).then((newTitle) => {
                            if (newTitle) {
                                // Rename thread from placeholder to generated title
                                renameThreadDirect(threadId, newTitle);
                            }
                        }).catch((err) => {
                            console.warn("Failed to auto-generate title:", err);
                            // Silently fail - keep placeholder title
                        });
                    }
                    // Clear loading state when response is complete
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                },
                onError: (err) => {
                    // Remove the optimistic entry on error
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.filter((entry) => entry.id !== entryId) ?? [],
                    }));
                    setError(err.message);
                    setLoading(false);
                    setLoadingStatus("Panel is thinking..."); // Reset status
                    setActiveEntryId(null);
                    clearEntryStatus(entryId);
                },
            }, controller.signal);
        }
        catch (err) {
            // Don't show error if request was aborted by user, but still clean up
            if (err instanceof Error && err.name === 'AbortError') {
                console.log('Request aborted by user');
                // Keep the entry but mark it as stopped
                setConversations((prev) => ({
                    ...prev,
                    [threadId]: prev[threadId]?.map((entry) => entry.id === entryId
                        ? {
                            ...entry,
                            summary: "Generation stopped by user.",
                            stopped: true,
                        }
                        : entry) ?? [],
                }));
                // Reset loading state
                setLoading(false);
                setLoadingStatus("Panel is thinking...");
                setActiveEntryId(null);
                clearEntryStatus(entryId);
                return;
            }
            // Remove the optimistic entry on error
            setConversations((prev) => ({
                ...prev,
                [threadId]: prev[threadId]?.filter((entry) => entry.id !== entryId) ?? [],
            }));
            setError(err instanceof Error ? err.message : "Something went wrong");
            throw err;
        }
        finally {
            setLoading(false);
            setLoadingStatus("Panel is thinking..."); // Reset status
            setAbortController(null); // Clean up abort controller
            setActiveEntryId(null);
        }
    }, [clearEntryStatus, loading, preparedPanelists, sanitizedProviderKeys, setEntryStatus, threadId]);
    const handleContinueDebate = useCallback(async (entryId) => {
        const entry = conversations[threadId]?.find((e) => e.id === entryId);
        if (!entry || !entry.debate_paused) {
            return;
        }
        setLoading(true);
        setError(null);
        setActiveEntryId(entryId);
        setEntryStatus(entryId, "Continuing debate...");
        // Create abort controller for this request
        const controller = new AbortController();
        setAbortController(controller);
        try {
            await askPanelStream({
                thread_id: threadId.trim(),
                question: "", // Not needed for continuation
                attachments: [],
                panelists: preparedPanelists,
                provider_keys: sanitizedProviderKeys,
                continue_debate: true, // Signal this is a continuation
            }, {
                onStatus: (message) => {
                    setLoadingStatus(message);
                    setEntryStatus(entryId, message);
                },
                onDebateRound: (round) => {
                    setEntryStatus(entryId, `Round ${round.round_number + 1} complete`);
                    // Add the new debate round
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((e) => e.id === entryId
                            ? {
                                ...e,
                                debate_history: [...(e.debate_history || []), round],
                            }
                            : e) ?? [],
                    }));
                },
                onDebatePaused: (result) => {
                    setEntryStatus(entryId, "Paused for review");
                    // Still paused - waiting for next round
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((e) => e.id === entryId
                            ? {
                                ...e,
                                panel_responses: result.panel_responses || e.panel_responses,
                                debate_paused: true,
                                usage: result.usage || e.usage,
                            }
                            : e) ?? [],
                    }));
                    // Clear loading state when debate pauses
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                },
                onResult: (result) => {
                    clearEntryStatus(entryId);
                    // Debate complete - got final summary
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((e) => e.id === entryId
                            ? {
                                ...e,
                                summary: result.summary,
                                panel_responses: result.panel_responses,
                                debate_paused: false,
                                usage: result.usage,
                            }
                            : e) ?? [],
                    }));
                    // Clear loading state when response is complete
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                },
                onError: (err) => {
                    setError(err.message);
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                    clearEntryStatus(entryId);
                },
            }, controller.signal);
        }
        catch (err) {
            // Don't show error if request was aborted by user
            if (err instanceof Error && err.name === 'AbortError') {
                console.log('Request aborted by user');
                // Reset loading state
                setLoading(false);
                setLoadingStatus("Panel is thinking...");
                setActiveEntryId(null);
                clearEntryStatus(entryId);
                return;
            }
            setError(err instanceof Error ? err.message : "Something went wrong");
        }
        finally {
            setLoading(false);
            setLoadingStatus("Panel is thinking...");
            setAbortController(null); // Clean up abort controller
            setActiveEntryId(null);
        }
    }, [clearEntryStatus, conversations, preparedPanelists, sanitizedProviderKeys, setEntryStatus, threadId]);
    const handleExitUserDebate = useCallback(async (entryId) => {
        const entry = conversations[threadId]?.find((e) => e.id === entryId);
        if (!entry || !entry.debate_paused) {
            return;
        }
        setLoading(true);
        setError(null);
        setActiveEntryId(entryId);
        setEntryStatus(entryId, "Exiting debate...");
        // Create abort controller for this request
        const controller = new AbortController();
        setAbortController(controller);
        try {
            await askPanelStream({
                thread_id: threadId.trim(),
                question: "", // Not needed for exit
                attachments: [],
                panelists: preparedPanelists,
                provider_keys: sanitizedProviderKeys,
                continue_debate: true,
                exit_user_debate: true, // Signal user is exiting user-debate
                debate_mode: entry.debate_mode,
                max_debate_rounds: entry.max_debate_rounds,
                step_review: entry.step_review,
            }, {
                onStatus: (message) => {
                    setLoadingStatus(message);
                    setEntryStatus(entryId, message);
                },
                onResult: (result) => {
                    clearEntryStatus(entryId);
                    // Debate complete - got final summary
                    setConversations((prev) => ({
                        ...prev,
                        [threadId]: prev[threadId]?.map((e) => e.id === entryId
                            ? {
                                ...e,
                                summary: result.summary,
                                panel_responses: result.panel_responses,
                                debate_paused: false,
                                usage: result.usage,
                            }
                            : e) ?? [],
                    }));
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                },
                onError: (err) => {
                    setError(err.message);
                    setLoading(false);
                    setLoadingStatus("Panel is thinking...");
                    setActiveEntryId(null);
                    clearEntryStatus(entryId);
                },
            }, controller.signal);
        }
        catch (err) {
            if (err instanceof Error && err.name === 'AbortError') {
                console.log('Exit debate aborted');
                setLoading(false);
                setLoadingStatus("Panel is thinking...");
                setActiveEntryId(null);
                clearEntryStatus(entryId);
                return;
            }
            setError(err instanceof Error ? err.message : "Something went wrong");
        }
        finally {
            setLoading(false);
            setLoadingStatus("Panel is thinking...");
            setAbortController(null);
            setActiveEntryId(null);
        }
    }, [clearEntryStatus, conversations, preparedPanelists, sanitizedProviderKeys, setEntryStatus, threadId]);
    const stopGeneration = useCallback(() => {
        if (abortController) {
            console.log('Stopping generation...');
            abortController.abort();
            setAbortController(null);
            setLoading(false);
            setLoadingStatus("Panel is thinking...");
            setActiveEntryId(null);
        }
    }, [abortController]);
    const handleScrollToBottom = useCallback(() => {
        const el = messageListRef.current;
        if (!el)
            return;
        el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
        setShowScrollToBottom(false);
    }, []);
    // Track scroll position for showing/hiding scroll button
    useEffect(() => {
        function handleScroll() {
            const el = messageListRef.current;
            if (!el)
                return;
            const distanceFromBottom = el.scrollHeight - el.scrollTop - el.clientHeight;
            setShowScrollToBottom(distanceFromBottom > 300);
        }
        handleScroll();
        const el = messageListRef.current;
        if (!el)
            return;
        el.addEventListener("scroll", handleScroll);
        return () => el.removeEventListener("scroll", handleScroll);
    }, []);
    function toggleEntry(index) {
        setConversations((prev) => ({
            ...prev,
            [threadId]: prev[threadId]?.map((item, i) => i === index ? { ...item, expanded: !item.expanded } : item) ?? [],
        }));
    }
    function handleThreadSelect(id) {
        setThreadId(id);
    }
    function handleRenameThread(id) {
        setEditingThreadId(id);
        setEditingThreadName(id);
    }
    function renameThreadDirect(oldId, newName) {
        const proposed = newName.trim();
        // Cancel if empty, unchanged, or duplicate
        if (!proposed || proposed === oldId || (proposed !== oldId && threads.includes(proposed))) {
            return;
        }
        setThreads((prev) => prev.map((thread) => (thread === oldId ? proposed : thread)));
        setConversations((prev) => {
            const { [oldId]: entries, ...rest } = prev;
            return { ...rest, [proposed]: entries ?? [] };
        });
        if (threadId === oldId) {
            setThreadId(proposed);
        }
    }
    function saveThreadRename() {
        if (!editingThreadId)
            return;
        const proposed = editingThreadName.trim();
        const oldId = editingThreadId;
        // Cancel if empty, unchanged, or duplicate
        if (!proposed || proposed === oldId || (proposed !== oldId && threads.includes(proposed))) {
            cancelThreadRename();
            return;
        }
        setThreads((prev) => prev.map((thread) => (thread === oldId ? proposed : thread)));
        setConversations((prev) => {
            const { [oldId]: entries, ...rest } = prev;
            return { ...rest, [proposed]: entries ?? [] };
        });
        if (threadId === oldId) {
            setThreadId(proposed);
        }
        setEditingThreadId(null);
        setEditingThreadName("");
    }
    function cancelThreadRename() {
        setEditingThreadId(null);
        setEditingThreadName("");
    }
    function handleDeleteThread(id) {
        if (threads.length === 1) {
            return;
        }
        setThreads((prev) => prev.filter((thread) => thread !== id));
        setConversations((prev) => {
            const { [id]: _removed, ...rest } = prev;
            return rest;
        });
        if (threadId === id) {
            const fallback = threads.find((thread) => thread !== id) ?? DEFAULT_THREAD_ID;
            setThreadId(fallback);
        }
    }
    function handleCreateThread() {
        // Generate timestamp-based placeholder name
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const ampm = hours >= 12 ? "PM" : "AM";
        const displayHours = hours % 12 || 12;
        const displayMinutes = minutes.toString().padStart(2, "0");
        const placeholderName = `Chat ${displayHours}:${displayMinutes} ${ampm}`;
        // Immediately create thread with placeholder
        setThreads((prev) => (prev.includes(placeholderName) ? prev : [...prev, placeholderName]));
        setConversations((prev) => (prev[placeholderName] ? prev : { ...prev, [placeholderName]: [] }));
        setThreadId(placeholderName);
    }
    const handleAddPanelist = useCallback(() => {
        setPanelists((prev) => {
            if (prev.length >= MAX_PANELISTS)
                return prev;
            const base = createPanelist(prev);
            const defaultModel = providerModels[base.provider]?.[0]?.id ?? "";
            const uniqueName = generateUniquePanelistName(base.provider, defaultModel, prev);
            return [...prev, { ...base, model: defaultModel, name: uniqueName }];
        });
    }, [providerModels]);
    const handleRemovePanelist = useCallback((id) => {
        setPanelists((prev) => {
            if (prev.length <= 1) {
                return prev;
            }
            const filtered = prev.filter((panelist) => panelist.id !== id);
            return filtered.length > 0 ? filtered : prev;
        });
    }, []);
    const handleProviderKeyChange = useCallback((provider, key) => {
        setProviderKeys((prev) => ({ ...prev, [provider]: key }));
    }, []);
    const handleFetchProviderModels = useCallback(async (provider) => {
        const apiKey = providerKeys[provider]?.trim();
        if (!apiKey) {
            setModelStatus((prev) => ({
                ...prev,
                [provider]: { loading: false, error: "API key required" },
            }));
            return;
        }
        setModelStatus((prev) => ({
            ...prev,
            [provider]: { loading: true, error: null },
        }));
        try {
            const models = await fetchModelsForProvider(provider, apiKey);
            setProviderModels((prev) => ({ ...prev, [provider]: models }));
            setModelStatus((prev) => ({
                ...prev,
                [provider]: { loading: false, error: null },
            }));
            setPanelists((prev) => {
                const updated = prev.map((panelist) => {
                    if (panelist.provider !== provider)
                        return panelist;
                    if (!models.length) {
                        return { ...panelist, model: "" };
                    }
                    let nextModel = panelist.model;
                    let shouldUpdateName = false;
                    // If panelist has no model, set to first available
                    if (!panelist.model) {
                        nextModel = models[0].id;
                        shouldUpdateName = true;
                    }
                    else {
                        // Try to find best match for the current model
                        const bestMatch = findBestModelMatch(panelist.model, models);
                        if (bestMatch && bestMatch.id !== panelist.model) {
                            // Found a different match - use it
                            nextModel = bestMatch.id;
                            shouldUpdateName = true;
                        }
                    }
                    // Auto-update name if model changed and name is auto-generated
                    let nextName = panelist.name;
                    if (shouldUpdateName && isAutoGeneratedName(panelist.name, panelist.provider, panelist.model)) {
                        nextName = generateUniquePanelistName(panelist.provider, nextModel, prev, panelist.id);
                    }
                    return { ...panelist, model: nextModel, name: nextName };
                });
                return updated;
            });
        }
        catch (err) {
            setModelStatus((prev) => ({
                ...prev,
                [provider]: {
                    loading: false,
                    error: err instanceof Error ? err.message : "Failed to fetch models",
                },
            }));
        }
    }, [providerKeys]);
    const handlePanelistChange = useCallback((id, updates) => {
        setPanelists((prev) => prev.map((panelist) => {
            if (panelist.id !== id)
                return panelist;
            const nextProvider = updates.provider ?? panelist.provider;
            const providerModelsList = providerModels[nextProvider] ?? [];
            let nextModel = updates.model ?? panelist.model;
            // Track if provider changed
            const providerChanged = updates.provider && updates.provider !== panelist.provider;
            if (providerChanged) {
                nextModel = providerModelsList[0]?.id ?? "";
                // Auto-fetch models if provider changed and we have an API key
                const hasKey = providerKeys[nextProvider]?.trim();
                const hasModels = (providerModels[nextProvider]?.length ?? 0) > 0;
                if (hasKey && !hasModels) {
                    // Fetch models asynchronously without blocking the UI
                    handleFetchProviderModels(nextProvider).catch((err) => {
                        console.error(`Failed to auto-fetch models for ${nextProvider}:`, err);
                    });
                }
            }
            // Auto-generate name if model/provider changed and current name is auto-generated
            let nextName = updates.name ?? panelist.name;
            const modelChanged = updates.model !== undefined && updates.model !== panelist.model;
            if ((modelChanged || providerChanged) && !updates.name) {
                // Check if current name is auto-generated (using OLD provider to check)
                const wasAutoGenerated = isAutoGeneratedName(panelist.name, panelist.provider, panelist.model);
                if (wasAutoGenerated) {
                    // Auto-update name to match new provider/model
                    nextName = generateUniquePanelistName(nextProvider, nextModel, prev, id);
                }
            }
            return {
                ...panelist,
                ...updates,
                provider: nextProvider,
                model: nextModel,
                name: nextName,
            };
        }));
    }, [providerModels, providerKeys, handleFetchProviderModels]);
    const handleLoadPreset = useCallback(async (preset) => {
        // Regenerate names based on current naming logic to ensure consistency
        const panelistsWithUpdatedNames = preset.panelists.map((panelist, index, arr) => {
            const uniqueName = generateUniquePanelistName(panelist.provider, panelist.model, arr.slice(0, index), // Only consider panelists before this one
            panelist.id);
            return { ...panelist, name: uniqueName };
        });
        // Set panelists with regenerated names
        setPanelists(panelistsWithUpdatedNames);
        // Auto-fetch models for providers used in the preset
        const providersUsed = new Set(preset.panelists.map((p) => p.provider));
        for (const provider of providersUsed) {
            // Fetch models if we have an API key
            const hasKey = providerKeys[provider]?.trim();
            if (hasKey) {
                // Always fetch models when loading preset to ensure proper matching
                // This triggers the smart model matching in handleFetchProviderModels
                handleFetchProviderModels(provider).catch((err) => {
                    console.error(`Failed to auto-fetch models for ${provider}:`, err);
                });
            }
        }
    }, [providerKeys, handleFetchProviderModels]);
    // Export/Import functions
    const exportThreadAsJSON = useCallback((threadId) => {
        const threadData = {
            threadId,
            messages: conversations[threadId] || [],
            exportedAt: new Date().toISOString(),
        };
        const blob = new Blob([JSON.stringify(threadData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${threadId}-${new Date().toISOString().split("T")[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }, [conversations]);
    const exportThreadAsMarkdown = useCallback((threadId) => {
        const messages = conversations[threadId] || [];
        let markdown = `# ${threadId}\n\n`;
        markdown += `*Exported: ${new Date().toLocaleString()}*\n\n---\n\n`;
        messages.forEach((entry, index) => {
            markdown += `## Exchange ${index + 1}\n\n`;
            markdown += `**You:**\n${entry.question}\n\n`;
            if (entry.attachments.length > 0) {
                markdown += `*Attachments: ${entry.attachments.length} image(s)*\n\n`;
            }
            markdown += `**Panel Summary:**\n${entry.summary}\n\n`;
            if (Object.keys(entry.panel_responses).length > 0) {
                markdown += `### Individual Responses\n\n`;
                Object.entries(entry.panel_responses).forEach(([name, response]) => {
                    markdown += `**${name}:**\n${response}\n\n`;
                });
            }
            markdown += `---\n\n`;
        });
        const blob = new Blob([markdown], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${threadId}-${new Date().toISOString().split("T")[0]}.md`;
        a.click();
        URL.revokeObjectURL(url);
    }, [conversations]);
    const importThread = useCallback((file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target?.result);
                if (!data.threadId || !Array.isArray(data.messages)) {
                    throw new Error("Invalid file format");
                }
                const newThreadId = data.threadId;
                let finalThreadId = newThreadId;
                let counter = 1;
                // Avoid overwriting existing threads
                while (threads.includes(finalThreadId)) {
                    finalThreadId = `${newThreadId} (${counter})`;
                    counter++;
                }
                setThreads((prev) => [...prev, finalThreadId]);
                setConversations((prev) => ({
                    ...prev,
                    [finalThreadId]: data.messages,
                }));
                setThreadId(finalThreadId);
            }
            catch (err) {
                setError("Failed to import conversation. Invalid file format.");
            }
        };
        reader.readAsText(file);
    }, [threads]);
    // Message management functions
    const copyToClipboard = useCallback((text) => {
        navigator.clipboard.writeText(text).then(() => {
            // Could add a toast notification here
        }).catch((err) => {
            console.error("Failed to copy:", err);
        });
    }, []);
    const deleteMessage = useCallback((index) => {
        setConversations((prev) => ({
            ...prev,
            [threadId]: prev[threadId]?.filter((_, i) => i !== index) ?? [],
        }));
    }, [threadId]);
    const openRegenerateModal = useCallback((index) => {
        setRegenerateIndex(index);
        setRegenerateModalOpen(true);
    }, []);
    const confirmRegenerate = useCallback(async (useDebateMode, rounds, useStepReview) => {
        if (regenerateIndex === null)
            return;
        const entry = conversations[threadId]?.[regenerateIndex];
        if (!entry)
            return;
        // Remove the old entry
        setConversations((prev) => ({
            ...prev,
            [threadId]: prev[threadId]?.filter((_, i) => i !== regenerateIndex) ?? [],
        }));
        // Re-send the question with custom debate settings
        await handleSend({
            question: entry.question,
            attachments: entry.attachments,
            customDebateMode: useDebateMode,
            customMaxRounds: rounds,
            customStepReview: useStepReview,
        });
        setRegenerateIndex(null);
    }, [regenerateIndex, threadId, conversations, handleSend]);
    return (_jsxs("div", { className: "flex h-screen w-full flex-col overflow-hidden bg-background", children: [storageInfo && storageInfo.persistent === "false" && (_jsxs("div", { className: "w-full bg-yellow-500/10 border-b border-yellow-500/30 px-4 py-2 flex items-center gap-2 text-sm", children: [_jsx("svg", { className: "w-4 h-4 text-yellow-600 dark:text-yellow-500 flex-shrink-0", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: _jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }), _jsx("span", { className: "text-yellow-800 dark:text-yellow-200 font-medium", children: "In-Memory Mode:" }), _jsx("span", { className: "text-yellow-700 dark:text-yellow-300", children: storageInfo.description })] })), _jsxs("div", { className: "flex h-full w-full overflow-hidden", children: [sidebarVisible && (_jsxs("aside", { className: "hidden lg:flex w-72 flex-shrink-0 bg-card px-6 py-8 flex-col gap-6 border-r border-border/60 relative", children: [_jsxs("div", { className: "flex items-center justify-between gap-3", children: [_jsx("h2", { className: "text-lg font-semibold m-0 text-foreground tracking-tight", children: "Conversations" }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsx("button", { type: "button", className: "w-8 h-8 rounded-lg border border-border/60 bg-muted/30 text-foreground text-lg font-semibold leading-none flex items-center justify-center cursor-pointer hover:bg-muted hover:border-accent/50 transition-all", onClick: handleCreateThread, "aria-label": "Create new thread", children: "+" }), _jsx("button", { type: "button", onClick: () => setSidebarVisible(false), className: "w-8 h-8 rounded-lg border border-border/60 text-muted-foreground hover:text-foreground hover:bg-muted/40 hover:border-accent/50 transition-all flex items-center justify-center", "aria-label": "Hide sidebar", title: "Hide sidebar", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 3H3v18h18V3z" }), _jsx("path", { d: "M10 3v18" }), _jsx("path", { d: "M4 14l3-3-3-3" })] }) })] })] }), _jsx("ul", { className: "list-none p-0 m-0 flex flex-col gap-1.5 overflow-y-auto flex-1", children: threads.map((id) => (_jsx("li", { className: "group relative", children: _jsxs("div", { className: "flex items-center relative", children: [editingThreadId === id ? (_jsx("input", { ref: renameInputRef, type: "text", value: editingThreadName, onChange: (e) => setEditingThreadName(e.target.value), onBlur: saveThreadRename, onKeyDown: (e) => {
                                                    if (e.key === "Enter") {
                                                        e.preventDefault();
                                                        saveThreadRename();
                                                    }
                                                    else if (e.key === "Escape") {
                                                        e.preventDefault();
                                                        cancelThreadRename();
                                                    }
                                                }, className: `w-full px-3.5 py-2 rounded-lg border text-[13px] transition-all bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-accent/40 ${threadId === id
                                                    ? "border-accent/60"
                                                    : "border-border/60"}` })) : (_jsx("button", { type: "button", className: `w-full flex items-center px-3.5 py-2 rounded-lg border text-[13px] transition-all ${threadId === id
                                                    ? "border-accent/60 bg-accent/8 text-accent font-medium"
                                                    : "border-border/40 bg-transparent font-normal text-foreground hover:bg-muted/30 hover:border-border"}`, onClick: () => handleThreadSelect(id), onDoubleClick: () => handleRenameThread(id), children: _jsx("span", { className: "truncate", children: id }) })), editingThreadId !== id && (_jsxs("div", { className: "absolute right-1 top-1/2 -translate-y-1/2", "data-thread-menu": true, children: [_jsx("button", { type: "button", onClick: (e) => {
                                                            e.stopPropagation();
                                                            setThreadMenuOpen(threadMenuOpen === id ? null : id);
                                                        }, "aria-label": "Thread options", className: `border-none cursor-pointer p-1.5 rounded-md transition-all ${threadMenuOpen === id
                                                            ? "bg-muted opacity-100"
                                                            : "bg-transparent opacity-0 group-hover:opacity-100 hover:bg-muted/60"}`, children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4 text-foreground/70", fill: "currentColor", children: [_jsx("circle", { cx: "12", cy: "5", r: "2" }), _jsx("circle", { cx: "12", cy: "12", r: "2" }), _jsx("circle", { cx: "12", cy: "19", r: "2" })] }) }), _jsx(AnimatePresence, { children: threadMenuOpen === id && (_jsxs(motion.div, { initial: { opacity: 0, scale: 0.95, y: -4 }, animate: { opacity: 1, scale: 1, y: 0 }, exit: { opacity: 0, scale: 0.95, y: -4 }, transition: { duration: 0.15 }, className: "absolute right-0 top-full mt-1 z-50 min-w-[140px] rounded-lg border border-border/60 bg-card shadow-lg py-1", children: [_jsxs("button", { type: "button", onClick: () => {
                                                                        handleRenameThread(id);
                                                                        setThreadMenuOpen(null);
                                                                    }, className: "w-full flex items-center gap-2 px-3 py-2 text-[13px] text-foreground hover:bg-muted/50 transition-colors text-left", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }), _jsx("path", { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" })] }), "Rename"] }), _jsxs("button", { type: "button", onClick: () => {
                                                                        exportThreadAsMarkdown(id);
                                                                        setThreadMenuOpen(null);
                                                                    }, className: "w-full flex items-center gap-2 px-3 py-2 text-[13px] text-foreground hover:bg-muted/50 transition-colors text-left", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }), _jsx("polyline", { points: "7 10 12 15 17 10" }), _jsx("line", { x1: "12", y1: "15", x2: "12", y2: "3" })] }), "Export"] }), _jsxs("button", { type: "button", onClick: () => {
                                                                        exportThreadAsJSON(id);
                                                                        setThreadMenuOpen(null);
                                                                    }, className: "w-full flex items-center gap-2 px-3 py-2 text-[13px] text-foreground hover:bg-muted/50 transition-colors text-left", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5 text-muted-foreground", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }), _jsx("polyline", { points: "14 2 14 8 20 8" }), _jsx("line", { x1: "16", y1: "13", x2: "8", y2: "13" }), _jsx("line", { x1: "16", y1: "17", x2: "8", y2: "17" })] }), "Export JSON"] }), _jsx("div", { className: "border-t border-border/40 my-1" }), _jsxs("button", { type: "button", onClick: () => {
                                                                        handleDeleteThread(id);
                                                                        setThreadMenuOpen(null);
                                                                    }, className: "w-full flex items-center gap-2 px-3 py-2 text-[13px] text-destructive hover:bg-destructive/10 transition-colors text-left", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M3 6h18" }), _jsx("path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }), _jsx("path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" })] }), "Delete"] })] })) })] }))] }) }, id))) }), _jsxs("div", { className: "flex flex-col gap-2 pt-4 border-t border-border/40 mt-auto", children: [_jsxs("div", { className: "flex items-center gap-2", children: [_jsxs("button", { type: "button", onClick: () => setConfigOpen(true), className: "flex-1 flex items-center justify-center gap-2 rounded-lg border border-border/60 px-4 py-2.5 text-[13px] font-medium text-foreground hover:bg-muted/40 hover:border-accent/50 transition-all", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("circle", { cx: "12", cy: "12", r: "3" }), _jsx("path", { d: "M12 1v6m0 6v6m5.2-13l-1 1.7M7.8 19.3l-1-1.7m0-11.6l1 1.7m4.2 9.3l1 1.7M1 12h6m6 0h6" })] }), "Settings"] }), _jsx(ThemeToggle, {})] }), _jsxs("button", { type: "button", onClick: () => document.getElementById("import-file-input")?.click(), className: "flex items-center justify-center gap-2 rounded-lg border border-border/60 px-4 py-2.5 text-[13px] font-medium text-foreground hover:bg-muted/40 hover:border-accent/50 transition-all", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }), _jsx("polyline", { points: "17 8 12 3 7 8" }), _jsx("line", { x1: "12", y1: "3", x2: "12", y2: "15" })] }), "Import Thread"] }), _jsx("input", { id: "import-file-input", type: "file", accept: ".json", className: "hidden", onChange: (e) => {
                                            const file = e.target.files?.[0];
                                            if (file) {
                                                importThread(file);
                                                e.target.value = ""; // Reset input
                                            }
                                        } }), _jsxs("button", { type: "button", onClick: () => setShowKeyboardShortcuts(true), className: "flex items-center justify-center gap-2 rounded-lg border border-border/60 px-4 py-2.5 text-[13px] font-medium text-foreground hover:bg-muted/40 hover:border-accent/50 transition-all", title: "Keyboard Shortcuts", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("rect", { x: "2", y: "4", width: "20", height: "16", rx: "2" }), _jsx("path", { d: "M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M7 16h10" })] }), "Keyboard Shortcuts"] })] })] })), !sidebarVisible && (_jsx("button", { type: "button", onClick: () => setSidebarVisible(true), className: "hidden lg:flex fixed left-4 top-6 z-50 w-10 h-10 items-center justify-center rounded-lg bg-card border border-border/60 text-muted-foreground hover:text-foreground hover:bg-muted/40 hover:border-accent/50 transition-all shadow-lg", "aria-label": "Show sidebar", title: "Show sidebar", children: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-5 h-5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M3 3h18v18H3V3z" }), _jsx("path", { d: "M10 3v18" }), _jsx("path", { d: "M14 8l3 3-3 3" })] }) })), _jsxs("main", { className: "flex-1 overflow-hidden bg-transparent flex flex-col", children: [_jsxs("div", { className: "mx-auto w-full max-w-4xl px-4 md:px-6 lg:px-8 py-6 flex flex-col gap-5", children: [_jsx("header", { className: "flex flex-col gap-2", children: _jsxs("div", { className: "min-w-0", children: [_jsx("p", { className: "m-0 text-[11px] text-muted-foreground/70 tracking-wider uppercase font-medium", children: "Thread" }), _jsx("h1", { className: "mt-0.5 mb-0 text-2xl font-semibold text-foreground truncate tracking-tight", children: threadId })] }) }), _jsxs("div", { className: "flex flex-wrap items-center gap-2 text-xs text-muted-foreground", children: [_jsxs("div", { className: "inline-flex items-center gap-1.5 rounded-lg border border-border/40 bg-card/50 px-3 py-1.5", title: "Moderator - Always active", children: [_jsx("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-amber-500", fill: "currentColor", children: _jsx("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" }) }), _jsx("span", { className: "font-semibold text-[12px] text-foreground", children: MODERATOR_PANELIST.name }), _jsxs("span", { className: "text-muted-foreground text-[11px]", children: ["\u00B7 ", PROVIDER_LABELS[MODERATOR_PANELIST.provider], MODERATOR_PANELIST.model ? ` Â· ${MODERATOR_PANELIST.model}` : ""] })] }), panelistSummaries.map((summary) => (_jsxs("button", { type: "button", onClick: () => togglePanelist(summary.id), className: `inline-flex items-center gap-1.5 rounded-lg border px-3 py-1.5 transition-all cursor-pointer ${summary.enabled
                                                    ? "border-border/40 bg-card/50 hover:bg-card hover:border-accent/40"
                                                    : "border-border/20 bg-muted/20 opacity-50 hover:opacity-70"}`, title: summary.enabled ? "Click to disable" : "Click to enable", children: [_jsx("span", { className: `font-semibold text-[12px] ${summary.enabled ? "text-foreground" : "text-muted-foreground"}`, children: summary.name }), _jsxs("span", { className: "text-muted-foreground text-[11px]", children: ["\u00B7 ", summary.provider, summary.model ? ` Â· ${summary.model}` : ""] }), summary.enabled && (_jsx("svg", { viewBox: "0 0 24 24", className: "w-3 h-3 text-accent", fill: "currentColor", children: _jsx("circle", { cx: "12", cy: "12", r: "4" }) }))] }, summary.id)))] })] }), _jsxs("section", { className: `flex flex-1 min-h-0 flex-col relative ${messages.length === 0 ? 'items-center justify-center' : ''}`, children: [_jsx("div", { className: `${messages.length === 0 ? '' : 'flex-1'} overflow-y-auto scroll-smooth`, ref: messageListRef, children: _jsx("div", { className: `flex flex-col gap-10 py-10 pb-16 mx-auto w-full max-w-3xl px-4 sm:px-6 ${messages.length === 0 ? 'hidden' : ''}`, children: messages.map((entry, index) => (_jsx(MessageBubble, { entry: entry, onToggle: () => toggleEntry(index), isLatest: index === messages.length - 1, messageRef: index === messages.length - 1 ? latestMessageRef : undefined, loadingStatus: loadingStatus, status: statusByEntryId[entry.id], statusTrail: statusTrailByEntryId[entry.id], searchSources: index === messages.length - 1 ? searchSources : [], onCopy: copyToClipboard, onDelete: () => deleteMessage(index), onRegenerate: () => openRegenerateModal(index), onContinueDebate: () => handleContinueDebate(entry.id), containerWidth: scrollContainerWidth }, entry.id))) }) }), _jsx("div", { className: "absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-background via-background/80 to-transparent pointer-events-none z-[5]" }), _jsx("div", { className: "absolute bottom-0 left-0 right-0 pointer-events-none z-[15]", children: _jsx("div", { className: "mx-auto w-full max-w-3xl px-4 sm:px-6 relative", children: _jsx(AnimatePresence, { children: showScrollToBottom && (_jsxs(motion.button, { type: "button", className: "absolute right-0 bottom-[210px] md:bottom-[220px] rounded-full bg-foreground/90 text-background pl-4 pr-5 py-2.5 shadow-lg text-[13px] font-medium hover:bg-foreground transition-all backdrop-blur-sm flex items-center gap-2 pointer-events-auto", onClick: handleScrollToBottom, initial: { opacity: 0, y: 10, scale: 0.9 }, animate: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: 10, scale: 0.9 }, transition: { duration: 0.2 }, children: [_jsx("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "currentColor", children: _jsx("path", { d: "M12 16l-6-6h12z" }) }), "Jump to latest"] })) }) }) }), _jsxs("div", { className: "pt-4 pb-4 relative z-10 mx-auto w-full max-w-3xl px-4 sm:px-6", children: [loading && (_jsx("div", { className: "mb-2 rounded-xl border border-border/50 bg-background/90 backdrop-blur-sm px-3 py-2 shadow-sm", children: _jsxs("div", { className: "flex items-center justify-between gap-3", children: [_jsxs("div", { className: "flex items-center gap-3 min-w-0", children: [_jsxs("div", { className: "flex gap-1.5", children: [_jsx("div", { className: "w-2 h-2 rounded-full bg-accent/40 animate-pulse" }), _jsx("div", { className: "w-2 h-2 rounded-full bg-accent/40 animate-pulse [animation-delay:150ms]" }), _jsx("div", { className: "w-2 h-2 rounded-full bg-accent/40 animate-pulse [animation-delay:300ms]" })] }), _jsx("span", { className: "text-sm text-muted-foreground truncate", children: activeEntryId ? statusByEntryId[activeEntryId] ?? loadingStatus : loadingStatus })] }), activeEntry?.debate_mode && (_jsxs("div", { className: "flex items-center gap-2 text-xs text-muted-foreground whitespace-nowrap", children: [activeEntry.step_review && (_jsx("span", { className: "px-2 py-0.5 rounded-full bg-accent/10 text-accent border border-accent/20", children: "Step Review" })), _jsxs("span", { children: ["Round ", (activeEntry.debate_history?.length ?? 0) + 1, "/", activeEntry.max_debate_rounds ?? DEFAULT_MAX_DEBATE_ROUNDS] })] }))] }) })), activeEntry?.debate_paused && activeEntry?.user_as_participant && (_jsx("div", { className: "flex gap-2 px-4 pb-4", children: _jsx("button", { onClick: () => handleExitUserDebate(activeEntry.id), disabled: loading, className: "px-4 py-2 rounded-lg bg-destructive/10 hover:bg-destructive/20 text-destructive text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed border border-destructive/30", children: "Exit Debate" }) })), _jsx(ChatComposer, { loading: loading, error: error, isNewChat: messages.length === 0, onSend: handleSend, onStop: stopGeneration, onClearError: () => setError(null), onError: (message) => setError(message) })] })] })] }), _jsx(PanelConfigurator, { open: configOpen, onClose: () => setConfigOpen(false), panelists: panelists, onPanelistChange: handlePanelistChange, onAddPanelist: handleAddPanelist, onRemovePanelist: handleRemovePanelist, providerKeys: providerKeys, onProviderKeyChange: handleProviderKeyChange, providerModels: providerModels, modelStatus: modelStatus, onFetchModels: handleFetchProviderModels, maxPanelists: MAX_PANELISTS, onLoadPreset: handleLoadPreset }), _jsx(RegenerateModal, { open: regenerateModalOpen, onClose: () => {
                            setRegenerateModalOpen(false);
                            setRegenerateIndex(null);
                        }, onConfirm: confirmRegenerate, defaultDebateMode: regenerateIndex !== null
                            ? conversations[threadId]?.[regenerateIndex]?.debate_mode ?? DEFAULT_DEBATE_MODE
                            : DEFAULT_DEBATE_MODE, defaultMaxRounds: regenerateIndex !== null
                            ? conversations[threadId]?.[regenerateIndex]?.max_debate_rounds ?? DEFAULT_MAX_DEBATE_ROUNDS
                            : DEFAULT_MAX_DEBATE_ROUNDS, defaultStepReview: regenerateIndex !== null
                            ? conversations[threadId]?.[regenerateIndex]?.step_review ?? DEFAULT_STEP_REVIEW
                            : DEFAULT_STEP_REVIEW }), _jsx(AnimatePresence, { children: showKeyboardShortcuts && (_jsx(motion.div, { className: "fixed inset-0 z-50 flex items-center justify-center bg-foreground/20 backdrop-blur-sm p-4", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, onClick: () => setShowKeyboardShortcuts(false), children: _jsxs(motion.div, { className: "bg-background text-foreground rounded-2xl shadow-2xl max-w-md w-full p-6 border border-border", initial: { scale: 0.9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: 0.9, opacity: 0 }, transition: { type: "spring", stiffness: 300, damping: 30 }, onClick: (e) => e.stopPropagation(), children: [_jsxs("div", { className: "flex items-center justify-between mb-6", children: [_jsx("h2", { className: "text-xl font-semibold m-0", children: "Keyboard Shortcuts" }), _jsx("button", { type: "button", onClick: () => setShowKeyboardShortcuts(false), className: "rounded-lg w-8 h-8 border border-border flex items-center justify-center hover:bg-muted transition-colors text-lg", "aria-label": "Close", children: "\u00D7" })] }), _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "flex items-center justify-between py-2 border-b border-border/40", children: [_jsx("span", { className: "text-sm text-muted-foreground", children: "New thread" }), _jsxs("kbd", { className: "px-2 py-1 text-xs font-semibold bg-muted rounded border border-border", children: [navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'â' : 'Ctrl', " + N"] })] }), _jsxs("div", { className: "flex items-center justify-between py-2 border-b border-border/40", children: [_jsx("span", { className: "text-sm text-muted-foreground", children: "Toggle settings" }), _jsxs("kbd", { className: "px-2 py-1 text-xs font-semibold bg-muted rounded border border-border", children: [navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'â' : 'Ctrl', " + /"] })] }), _jsxs("div", { className: "flex items-center justify-between py-2 border-b border-border/40", children: [_jsx("span", { className: "text-sm text-muted-foreground", children: "Submit message" }), _jsxs("kbd", { className: "px-2 py-1 text-xs font-semibold bg-muted rounded border border-border", children: [navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'â' : 'Ctrl', " + Enter"] })] }), _jsxs("div", { className: "flex items-center justify-between py-2", children: [_jsx("span", { className: "text-sm text-muted-foreground", children: "Close modals" }), _jsx("kbd", { className: "px-2 py-1 text-xs font-semibold bg-muted rounded border border-border", children: "Esc" })] })] }), _jsx("div", { className: "mt-6 pt-4 border-t border-border/40", children: _jsxs("p", { className: "text-xs text-muted-foreground text-center", children: ["Press ", _jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-semibold bg-muted rounded border border-border", children: "?" }), " anytime to show this help"] }) })] }) })) })] })] }));
}
function ChatComposer({ loading, error, isNewChat = false, onSend, onStop, onClearError, onError, }) {
    const [question, setQuestion] = useState("");
    const [attachments, setAttachments] = useState([]);
    const [debateSettingsOpen, setDebateSettingsOpen] = useState(false);
    const [debateMode, setDebateMode] = useState(DEFAULT_DEBATE_MODE);
    const [maxDebateRounds, setMaxDebateRounds] = useState(DEFAULT_MAX_DEBATE_ROUNDS);
    const [stepReview, setStepReview] = useState(DEFAULT_STEP_REVIEW);
    const fileInputRef = useRef(null);
    const textareaRef = useRef(null);
    const hasContent = Boolean(question.trim()) || attachments.length > 0;
    const canSubmit = hasContent && !loading;
    const canStop = loading;
    // Auto-resize textarea based on content
    useEffect(() => {
        const textarea = textareaRef.current;
        if (!textarea)
            return;
        // Reset height to get accurate scrollHeight
        textarea.style.height = 'auto';
        // Set height based on content, with max limit to keep cursor visible above buttons
        const maxHeight = 300; // Allow ~12-15 lines before scrollbar appears
        const newHeight = Math.min(textarea.scrollHeight, maxHeight);
        textarea.style.height = `${newHeight}px`;
        // Only show scrollbar when content exceeds max height
        textarea.style.overflowY = textarea.scrollHeight > maxHeight ? 'auto' : 'hidden';
    }, [question]);
    async function handleSubmit(event) {
        event.preventDefault();
        if (!canSubmit)
            return;
        // Clear immediately for better UX
        const currentQuestion = question;
        const currentAttachments = [...attachments];
        const currentDebateMode = debateMode;
        const currentMaxRounds = maxDebateRounds;
        const currentStepReview = stepReview;
        setQuestion("");
        setAttachments([]);
        // Refocus textarea
        textareaRef.current?.focus();
        try {
            await onSend({
                question: currentQuestion,
                attachments: currentAttachments,
                customDebateMode: currentDebateMode,
                customMaxRounds: currentMaxRounds,
                customStepReview: currentStepReview,
            });
        }
        catch {
            // On error, restore the content
            setQuestion(currentQuestion);
            setAttachments(currentAttachments);
        }
    }
    function handleFilesSelected(files) {
        if (!files)
            return;
        const toRead = Array.from(files).slice(0, 4);
        Promise.all(toRead.map((file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(String(reader.result));
            reader.onerror = reject;
            reader.readAsDataURL(file);
        })))
            .then((data) => {
            setAttachments((prev) => [...prev, ...data]);
            if (error)
                onClearError();
        })
            .catch(() => onError("Failed to load image"));
    }
    function removeAttachment(index) {
        setAttachments((prev) => prev.filter((_, i) => i !== index));
    }
    return (_jsxs(_Fragment, { children: [_jsx("form", { className: "min-w-0", onSubmit: handleSubmit, children: _jsxs("div", { className: "flex flex-col gap-3 min-w-0", children: [_jsxs("div", { className: "relative rounded-2xl border border-border/50 bg-background/95 backdrop-blur-sm max-w-full shadow-sm", children: [_jsx("textarea", { ref: textareaRef, value: question, onChange: (event) => {
                                        setQuestion(event.target.value);
                                        if (error)
                                            onClearError();
                                    }, onKeyDown: (event) => {
                                        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                                        const modKey = isMac ? event.metaKey : event.ctrlKey;
                                        // Cmd/Ctrl + Enter: Submit
                                        if (modKey && event.key === 'Enter' && canSubmit) {
                                            event.preventDefault();
                                            handleSubmit(event);
                                        }
                                    }, placeholder: isNewChat ? "Start conversation..." : "Send a message...", rows: 1, className: "w-full border-none rounded-2xl px-4 md:px-5 pt-3.5 md:pt-4 pb-14 md:pb-16 text-sm md:text-[15px] font-inherit resize-none overflow-y-hidden bg-transparent text-foreground placeholder:text-muted-foreground/50 focus:outline-none leading-relaxed" }), _jsx("div", { className: "absolute left-0 right-0 bottom-0 pt-3 px-4 md:px-5 pb-3.5 md:pb-4 bg-gradient-to-t from-background/95 via-background/80 to-transparent border-t border-border/20 rounded-b-2xl", children: _jsxs("div", { className: "flex items-center gap-2 md:gap-2.5", children: [_jsxs("button", { type: "button", className: "inline-flex items-center gap-1.5 px-3 py-2 rounded-lg border border-border/50 bg-background/90 text-foreground text-xs font-medium cursor-pointer hover:bg-muted/60 hover:border-border transition-all shadow-sm", onClick: () => fileInputRef.current?.click(), children: [_jsx("svg", { viewBox: "0 0 24 24", "aria-hidden": "true", className: "w-3.5 h-3.5", children: _jsx("path", { fill: "currentColor", d: "M16.5 6.5v9.25a4.25 4.25 0 0 1-8.5 0V5a2.75 2.75 0 0 1 5.5 0v9a1.25 1.25 0 0 1-2.5 0V6.5h-1.5V14a2.75 2.75 0 1 0 5.5 0V5a4.25 4.25 0 0 0-8.5 0v10.75a5.75 5.75 0 1 0 11.5 0V6.5z" }) }), _jsx("span", { className: "hidden sm:inline", children: "Attach" })] }), _jsxs("button", { type: "button", onClick: () => setDebateSettingsOpen(true), className: `inline-flex items-center gap-1.5 px-3 py-2 rounded-lg border text-xs font-medium cursor-pointer transition-all shadow-sm ${debateMode
                                                    ? "border-accent/60 bg-accent/10 text-accent hover:bg-accent/20"
                                                    : "border-border/50 bg-background/90 text-foreground hover:bg-muted/60 hover:border-border"}`, title: debateMode ? "Debate mode enabled - click to configure" : "Click to configure debate mode", children: [_jsxs("svg", { viewBox: "0 0 24 24", className: "w-3.5 h-3.5", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }), _jsx("path", { d: "M8 10h.01M12 10h.01M16 10h.01" })] }), _jsx("span", { className: "hidden sm:inline", children: "Debate" }), debateMode && (_jsxs("span", { className: "hidden sm:inline text-[10px] opacity-70", children: ["(", maxDebateRounds, ")"] }))] }), _jsx("input", { ref: fileInputRef, type: "file", accept: "image/*", multiple: true, hidden: true, onChange: (event) => {
                                                    handleFilesSelected(event.target.files);
                                                    event.target.value = "";
                                                } }), _jsx(motion.button, { type: canStop ? "button" : "submit", onClick: canStop ? (e) => { e.preventDefault(); onStop(); } : undefined, className: `ml-auto w-10 h-10 md:w-11 md:h-11 rounded-xl inline-flex items-center justify-center border-none cursor-pointer transition-all shadow-sm disabled:opacity-40 disabled:cursor-not-allowed ${canStop
                                                    ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90'
                                                    : 'bg-accent text-accent-foreground hover:opacity-90'}`, disabled: !canSubmit && !canStop, "aria-label": canStop ? "Stop generation" : "Send message", whileHover: { scale: (canSubmit || canStop) ? 1.05 : 1 }, whileTap: { scale: (canSubmit || canStop) ? 0.95 : 1 }, animate: {
                                                    opacity: (hasContent || canStop) ? 1 : 0.3,
                                                    scale: (hasContent || canStop) ? 1 : 0.9
                                                }, transition: { duration: 0.2 }, children: canStop ? (_jsx("svg", { viewBox: "0 0 24 24", className: "w-5 h-5", fill: "currentColor", children: _jsx("rect", { x: "6", y: "6", width: "12", height: "12", rx: "1" }) })) : (_jsx("svg", { viewBox: "0 0 24 24", "aria-hidden": "true", className: "w-5 h-5", children: _jsx("path", { fill: "currentColor", d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z" }) })) })] }) })] }), _jsx(AnimatePresence, { children: attachments.length > 0 && (_jsx(motion.div, { className: "flex flex-wrap gap-2.5", initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, children: attachments.map((src, index) => (_jsxs(motion.div, { className: "relative w-20 h-20 rounded-xl overflow-hidden border-2 border-border/40 shadow-sm group", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, transition: { duration: 0.2, delay: index * 0.03 }, children: [_jsx("img", { src: src, alt: `preview-${index + 1}`, className: "w-full h-full object-cover" }), _jsx("button", { type: "button", onClick: () => {
                                                removeAttachment(index);
                                                if (error)
                                                    onClearError();
                                            }, className: "absolute top-1 right-1 border-none rounded-full w-6 h-6 text-xs bg-foreground/90 text-background cursor-pointer hover:bg-foreground transition-all opacity-0 group-hover:opacity-100 flex items-center justify-center font-semibold shadow-sm", children: "\u00D7" })] }, index))) })) }), _jsx(AnimatePresence, { children: error && (_jsx(motion.p, { className: "text-destructive text-[13px] m-0 px-1", initial: { opacity: 0, y: -5 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -5 }, children: error })) })] }) }), _jsx(RegenerateModal, { open: debateSettingsOpen, onClose: () => setDebateSettingsOpen(false), onConfirm: (enabled, rounds, useStepReview) => {
                    setDebateMode(enabled);
                    setMaxDebateRounds(rounds);
                    setStepReview(useStepReview);
                }, defaultDebateMode: debateMode, defaultMaxRounds: maxDebateRounds, defaultStepReview: stepReview, title: "Debate Settings", subtitle: "Choose settings for your next message", confirmLabel: "Apply", headerIcon: _jsxs("svg", { viewBox: "0 0 24 24", className: "w-5 h-5 text-accent", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [_jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }), _jsx("path", { d: "M8 10h.01M12 10h.01M16 10h.01" })] }), confirmIcon: _jsx("svg", { viewBox: "0 0 24 24", className: "w-4 h-4", fill: "none", stroke: "currentColor", strokeWidth: "2", children: _jsx("path", { d: "M20 6L9 17l-5-5" }) }) })] }));
}
