import { PROVIDER_LABELS } from "./modelProviders";
/**
 * Extract a friendly short name from a model ID
 * Examples:
 * - "gpt-4o" → "GPT-4o"
 * - "gpt-4o-mini" → "GPT-4o Mini"
 * - "claude-3-5-sonnet-20241022" → "Claude Sonnet"
 * - "gemini-1.5-flash" → "Gemini Flash"
 * - "grok-2-1212" → "Grok 2"
 */
export function generateFriendlyModelName(provider, modelId) {
    if (!modelId) {
        return PROVIDER_LABELS[provider];
    }
    const modelLower = modelId.toLowerCase();
    // OpenAI models
    if (provider === "openai") {
        if (modelLower.includes("gpt-4o")) {
            if (modelLower.includes("mini"))
                return "GPT-4o Mini";
            return "GPT-4o";
        }
        if (modelLower.includes("gpt-4")) {
            if (modelLower.includes("turbo"))
                return "GPT-4 Turbo";
            return "GPT-4";
        }
        if (modelLower.includes("o1-mini"))
            return "o1 Mini";
        if (modelLower.includes("o1"))
            return "o1";
        if (modelLower.includes("o3-mini"))
            return "o3 Mini";
        if (modelLower.includes("o3"))
            return "o3";
        if (modelLower.includes("gpt-3.5"))
            return "GPT-3.5";
    }
    // Claude models
    if (provider === "claude") {
        // Extract version (e.g., "3.5", "4", "4.5")
        const versionMatch = modelLower.match(/(\d+(?:\.\d+)?)/);
        const version = versionMatch ? versionMatch[1] : "";
        if (modelLower.includes("opus")) {
            return version ? `Claude ${version} Opus` : "Claude Opus";
        }
        if (modelLower.includes("sonnet")) {
            return version ? `Claude ${version} Sonnet` : "Claude Sonnet";
        }
        if (modelLower.includes("haiku")) {
            return version ? `Claude ${version} Haiku` : "Claude Haiku";
        }
    }
    // Gemini models
    if (provider === "gemini") {
        const isFlash = modelLower.includes("flash");
        const isPro = modelLower.includes("pro");
        const version = modelLower.match(/(\d+\.?\d*)/)?.[0] || "";
        if (isFlash)
            return version ? `Gemini ${version} Flash` : "Gemini Flash";
        if (isPro)
            return version ? `Gemini ${version} Pro` : "Gemini Pro";
        return "Gemini";
    }
    // Grok models
    if (provider === "grok") {
        const versionMatch = modelLower.match(/grok-(\d+)/);
        if (versionMatch)
            return `Grok ${versionMatch[1]}`;
        return "Grok";
    }
    // Fallback to provider name
    return PROVIDER_LABELS[provider];
}
/**
 * Generate a unique panelist name based on provider and model
 * Handles duplicates by adding number suffixes (e.g., "GPT-4o 2")
 */
export function generateUniquePanelistName(provider, modelId, existingPanelists, currentPanelistId) {
    const baseName = generateFriendlyModelName(provider, modelId);
    // Get all existing names except the current panelist (if updating)
    const existingNames = existingPanelists
        .filter((p) => p.id !== currentPanelistId)
        .map((p) => p.name);
    // If base name is unique, use it
    if (!existingNames.includes(baseName)) {
        return baseName;
    }
    // Find the next available number suffix
    let suffix = 2;
    let candidateName = `${baseName} ${suffix}`;
    while (existingNames.includes(candidateName)) {
        suffix++;
        candidateName = `${baseName} ${suffix}`;
    }
    return candidateName;
}
/**
 * Check if a name appears to be auto-generated (not manually edited)
 * This helps determine if we should auto-update the name when model changes
 */
export function isAutoGeneratedName(name, provider, modelId) {
    if (!name || !modelId)
        return false;
    const friendlyName = generateFriendlyModelName(provider, modelId);
    // Check if it matches exactly or with a number suffix
    if (name === friendlyName)
        return true;
    // Check if it matches with number suffix (e.g., "GPT-4o 2")
    const suffixPattern = new RegExp(`^${friendlyName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')} \\d+$`);
    return suffixPattern.test(name);
}
